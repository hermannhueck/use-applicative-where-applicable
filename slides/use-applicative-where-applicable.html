<!DOCTYPE html>
<html>

<head>
  <title>Use Applicative where applicable!</title>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta name="keywords" content="Scala,Cats,Applicative,Monad">
  <meta name="description" content="A talk on the merits of Applicative.">

  <style type="text/css">
    @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
    @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
    @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

    body {
      font-family: 'Droid Serif';
    }

    h1,
    h2,
    h3 {
      font-family: 'Yanone Kaffeesatz';
      font-weight: 400;
      margin-bottom: 0;
    }

    .remark-slide-content h1 {
      font-size: 4em;
    }

    .remark-slide-content h2 {
      font-size: 2.5em;
    }

    .remark-slide-content h3 {
      font-size: 1.6em;
    }

    .footnote {
      position: absolute;
      bottom: 3em;
    }

    li p {
      line-height: 1.25em;
    }

    .red {
      color: #fa0000;
    }

    .large {
      font-size: 2em;
    }

    a,
    a>code {
      color: rgb(249, 38, 114);
      text-decoration: none;
    }

    code {
      background: #e7e8e2;
      border-radius: 5px;
    }

    .remark-code,
    .remark-inline-code {
      font-family: 'Ubuntu Mono';
    }

    .remark-code-line-highlighted {
      background-color: #373832;
    }

    .pull-left {
      float: left;
      width: 47%;
    }

    .pull-right {
      float: right;
      width: 47%;
    }

    .pull-right~p {
      clear: both;
    }

    #slideshow .slide .content code {
      font-size: 0.8em;
    }

    #slideshow .slide .content pre code {
      font-size: 0.9em;
      padding: 15px;
    }

    .inverse {
      background: #014908e1;
      color: #f3f3f3;
      text-shadow: 0 0 20px #333;
    }

    .inverse h1,
    .inverse h2 {
      color: #f3f3f3;
      line-height: 0.8em;
    }

    /* Slide-specific styling */
    #slide-inverse .footnote {
      bottom: 12px;
      left: 20px;
    }

    #slide-how .slides {
      font-size: 0.9em;
      position: absolute;
      top: 151px;
      right: 140px;
    }

    #slide-how .slides h3 {
      margin-top: 0.2em;
    }

    #slide-how .slides .first,
    #slide-how .slides .second {
      padding: 1px 20px;
      height: 90px;
      width: 120px;
      -moz-box-shadow: 0 0 10px #777;
      -webkit-box-shadow: 0 0 10px #777;
      box-shadow: 0 0 10px #777;
    }

    #slide-how .slides .first {
      background: #fff;
      position: absolute;
      top: 20%;
      left: 20%;
      z-index: 1;
    }

    #slide-how .slides .second {
      position: relative;
      background: #fff;
      z-index: 0;
    }

    /* Two-column layout */
    .left-column {
      color: #777;
      width: 20%;
      height: 92%;
      float: left;
    }

    .left-column h2:last-of-type,
    .left-column h3:last-child {
      color: #000;
    }

    .right-column {
      width: 75%;
      float: right;
      padding-top: 1em;
    }

    /* Two-column layout 50/50 */
    .left-column-50 {
      width: 49%;
      float: left;
    }

    .right-column-50 {
      width: 49%;
      float: right;
    }

    .tiny-font {
      font-size: 1em
    }
  </style>
</head>

<body>

  <textarea id="source">

name: main-template
layout: true
class: left, top
<!---
class: left, top, inverse
-->

---

class: center

<br/>
# Use Applicative
# where applicable!
<br/>
<br/>
<br/>
## &copy; 2020 Hermann Hueck
<br/>
https://github.com/hermannhueck/use-applicative-where-applicable

---

# Abstract
<br/>
<br/>
Most Scala developers are familiar with monadic processing.
Monads provide *flatMap* and hence for-comprehensions
(syntactic sugar for *map* and *flatMap*).

Often we don't need Monads.
Applicatives are sufficient in many cases.

In this talk I examine the differences between monadic and applicative processing
and give some guide lines when to use which.

After a closer look to the Applicative trait
I will contrast the gist of *Either* and *cats.data.Validated* (the latter being an Applicative but not a Monad).

I will also look at traversing and sequencing which harness Applicatives as well.

.footnote[
(The code examples are implemented with *Cats*.)
]


---

# Agenda
<br/>

1. Monadic Processing
1. Aside: Effects
1. Aside: Curried functions
1. Where Functor is too weak
1. Applicative Processing
1. Comparing Monad with Applicative
1. The Applicative trait
1. Either vs. Validated
1. Traversals need Applicative
1. Resources

---

class: middle, center

# 1. Monadic Processing
<br/>
<br/>
<br/>
<br/>
<br/>

.footnote[
&nbsp; &nbsp; &nbsp; &nbsp; See: *examples.MonadicProcessing*
]

---

## The Problem:
### How to compute values wrapped in a context?

### Example context/effect: *Option*
<br/>

```scala
def processInts(compute: (Int, Int, Int) => Int)
               (oi1: Option[Int], oi2: Option[Int], oi3: Option[Int])
               : Option[Int] = ???
```

--

```scala
val sum3Ints: (Int, Int, Int) => Int = _ + _ + _

val result1 = processInts(sum3Ints, Some(1), Some(2), Some(3))
// result1: Option[Int] = Some(6)

val result2 = processInts(sum3Ints, Some(1), Some(2), None)
// result2: Option[Int] = None
```

---

## The Standard Solution:
### Monadic Processing with a for-comprehension (monad comprehension)

### Example context/effect: *Option*
<br/>

```scala
def processInts(compute: (Int, Int, Int) => Int)
               (oi1: Option[Int], oi2: Option[Int], oi3: Option[Int])
               : Option[Int] =
  for {
    i1 <- oi1
    i2 <- oi2
    i3 <- oi3
  } yield compute(i1, i2, i3)
```

--

```scala
val sum3Ints: (Int, Int, Int) => Int = _ + _ + _

val result1 = processInts(sum3Ints, Some(1), Some(2), Some(3))
// result1: Option[Int] = Some(6)

val result2 = processInts(sum3Ints, Some(1), Some(2), None)
// result2: Option[Int] = None
```

---

## Abstracting *Option* to *F[_]: Monad*
<br/>

```scala
def processInts[F[_]: Monad](compute: (Int, Int, Int) => Int)
                            (fi1: F[Int], fi2: F[Int], fi3: F[Int]): F[Int] =
  for {
    i1 <- fi1
    i2 <- fi2
    i3 <- fi3
  } yield compute(i1, i2, i3)
```

--

```scala
val sum3Ints: (Int, Int, Int) => Int = _ + _ + _

val result1 = processInts(sum3Ints, Some(1), Some(2), Some(3))
// result1: Option[Int] = Some(6)

val result2 = processInts(sum3Ints, Some(1), Some(2), None)
// result2: Option[Int] = None

val result3 = processInts(sum3Ints)(List(1, 2), List(10, 20), List(100, 200))
// result3: List[Int] = List(111, 211, 121, 221, 112, 212, 122, 222)

val result4 = processInts(sum3Ints)(Future(1), Future(2), Future(3))
Await.ready(result4, 1 second)
// result4 = scala.concurrent.Future[Int] = Future(Success(6))
```

---

## Abstracting away the *Int*s
<br/>

```scala
def processABC[F[_]: Monad, A, B, C, D](compute: (A, B, C) => D)
                                       (fa: F[A], fb: F[B], fc: F[C]): F[D] =
  for {
    a <- fa
    b <- fb
    c <- fc
  } yield compute(a, b, c)
```

--

```scala
val sum3Ints: (Int, Int, Int) => Int = _ + _ + _

val result1 = processABC(sum3Ints, Some(1), Some(2), Some(3))
// result1: Option[Int] = Some(6)

val result2 = processABC(sum3Ints, Some(1), Some(2), None)
// result2: Option[Int] = None

val result3 = processABC(sum3Ints)(List(1, 2), List(10, 20), List(100, 200))
// result3: List[Int] = List(111, 211, 121, 221, 112, 212, 122, 222)

val result4 = processABC(sum3Ints)(Future(1), Future(2), Future(3))
Await.ready(result4, 1 second)
// result4 = scala.concurrent.Future[Int] = Future(Success(6))
```

---

## Desugaring for-comprehension to *map/flatMap*
<br/>

```scala
def processABC[F[_]: Monad, A, B, C, D](compute: (A, B, C) => D)
                                       (fa: F[A], fb: F[B], fc: F[C]): F[D] =
  fa flatMap { a =>
    fb flatMap { b =>
      fc map { c =>
        compute(a, b, c)
      }
    }
  }
```

---

class: middle, center

# 2. Aside: Effects
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

##  What is *F[_]* ?
<br/>
*F[_]* is a type constructor.

It represents the <u>__computational context__</u> of the operation, also called the <u>__effect__</u> of the operation.

.center[
## effect != side effect
]

<br/>
With the context bound *F[_]: Monad* we constrain the effect to be a Monad.

This makes *F* a place holder for any Monad which provides us *map* and *flatMap*.

---

## Some Effects
<br/>
<br/>

| &nbsp; <u>F[_]</u>   | &nbsp; &nbsp; &nbsp; <u>Effect</u>
|----------------------|-----------------------------------------------
| &nbsp; Option        | &nbsp; &nbsp; &nbsp; a possibly missing value
| &nbsp; List          | &nbsp; &nbsp; &nbsp; an arbitrary number of values of the same type (non-determinism)
| &nbsp; Future        | &nbsp; &nbsp; &nbsp; an asyncronously computed value
| &nbsp; Either        | &nbsp; &nbsp; &nbsp; either a value of a type or a value of another type
| &nbsp; Id            | &nbsp; &nbsp; &nbsp; the effect of having no effect
| &nbsp; IO            | &nbsp; &nbsp; &nbsp; the effect of having a side effect
| &nbsp; Tuple2        | &nbsp; &nbsp; &nbsp; two adjacent values of possibly different type
| &nbsp; Function1     | &nbsp; &nbsp; &nbsp; a pure computation on a (yet unknown) input producing an output
| &nbsp; Reader        | &nbsp; &nbsp; &nbsp; a wrapped Function1
| &nbsp; Writer        | &nbsp; &nbsp; &nbsp; a values that has another value attached which acts as a log message accumulator

---

class: middle, center

# 3. Aside: Curried functions
<br/>
<br/>
<br/>
<br/>
<br/>

.footnote[
&nbsp; &nbsp; &nbsp; &nbsp; See: *examples.CurriedFunctions*
]

---

## Every function is a *Function1* ...

--

```scala
val sum3Ints : (Int, Int, Int) => Int        = _ + _ + _
val sum3Ints2: Function3[Int, Int, Int, Int] = _ + _ + _
```

--

... if we curry it.

--

```scala
val sumCurried: Int => Int => Int => Int = sum3Ints.curried
// sumCurried: Int => (Int => (Int => Int)) = scala.Function3$$Lambda$4346/99143056@43357c0e
```

--

The type arrow ( => ) is right associative.
Hence we can omit the parentheses.

--

The type arrow ( => ) is syntactic sugar for Function1.<br/>
*A => B* is equivalent to *Function1[A, B]*.

--

```scala
val sumCurried2: Function1[Int, Function1[Int, Function1[Int, Int]]] = sumCurried
// sumCurried2: Int => (Int => (Int => Int)) = scala.Function3$$Lambda$4346/99143056@7567ab8
```

--

If uncurried again, we get the original function back.

```scala
val sumUncurried: (Int, Int, Int) => Int = Function.uncurried(sumCurried)
// sumUncurried: (Int, Int, Int) => Int = scala.Function$$$Lambda$6605/301079867@1589d895
```

---

## Partial application of curried functions
<br/>

--

```scala
val sum3Ints: (Int, Int, Int) => Int = _ + _ + _
val sumCurried: Int => Int => Int => Int = sum3Ints.curried
```

--

```scala
val applied1st: Int => Int => Int = sumCurried(1)
```

--

```scala
val applied2nd: Int => Int = applied1st(2)
```

--

```scala
val applied3rd: Int = applied2nd(3)
```

--

```scala
val appliedAllAtOnce: Int = sumCurried(1)(2)(3)
```

---

## Advantages of curried functions
<br/>

--

1. As curried functions can be partially applied.<br/>
They are better <u>composable</u> than their uncurried counterparts.

--

2. Curried functions help the compiler with type inference. The compiler infers types
by argument lists from left to right.

--

```scala
def filter1[A](la: List[A], p: A => Boolean) = ??? // uncurried

scala> filter1(List(0,1,2), _ < 2)
<console>:50: error: missing parameter type for expanded function ((x$1: <error>) => x$1.$less(2))
       filter1(List(0,1,2), _ < 2)
                            ^
```

--

```scala
def filter2[A](la: List[A])(p: A => Boolean) = ??? // curried

scala> filter2(List(0,1,2))(_ < 2)
res5: List[Int] = List(0,1)
```

---

## Curring in Java? -- (Sorry, I couldn't resist &nbsp; ;-)

--

```java
// Curring with lambdas
Function<Integer, Function<Integer, Function<Integer, Integer>>> sum3IntsCurried =
  a -> b -> c -> a + b + c;
  
Integer result = sum3IntsCurried.apply(1).apply(2).apply(3);
```

--

```java
// Curring without lambdas
Function<Integer, Function<Integer, Function<Integer, Integer>>> sum3IntsCurried =
  new Function<Integer, Function<Integer, Function<Integer, Integer>>>() {
      @Override
      public Function<Integer, Function<Integer, Integer>> apply(Integer a) {
          return new Function<Integer, Function<Integer, Integer>>() {
              @Override
              public Function<Integer, Integer> apply(Integer b) {
                  return new Function<Integer, Integer>() {
                      @Override
                      public Integer apply(Integer c) {
                          return a + b + c;
                      }
                  };
              }
          };
      }
  };
Integer result = sum3IntsCurried.apply(1).apply(2).apply(3);
```

---

## Curring in Haskell?
<br/>

--

### No extra currying!

--

### Every function is already curried.<br/>
It can take only one parameter ...<br/>
... and returns only one value which might be another function.

--

Invoking functions with more than one parameter is possible.<br/>
That is just syntactic sugar for curried functions.

---

## Partial application in Haskell
<br/>
<br/>

```haskell
sum3Ints :: Int -> Int -> Int -> Int  -- function already curried
sum3Ints x y z = x + y + z

applied1st = sum3Ints 1        :: Int -> Int -> Int
applied2nd = applied1st 2      :: Int -> Int
applied3rd = applied2nd 3      :: Int
appliedAll = sum3Ints 1 2 3    :: Int
```

---

class: middle, center

# 4. Where Functor is too weak
<br/>
<br/>
<br/>
<br/>
<br/>

.footnote[
&nbsp; &nbsp; &nbsp; &nbsp; See: *examples.WhereFunctorIsTooWeak*
]

---

## Where Functor is too weak ...

--

What to do if we want to fuse two Options to one
by summing up the contained values?

Option(1) + Option(2) == Option(3) // ???

--

```scala
val add1: Int => Int = 1 + _
val sum2Ints: (Int, Int) => Int = _ + _
```

--

```scala
Option(1) map add1
// res1: Option[Int] = Some(2)
```

--

```scala
// Option(1) map sum2Ints
//  [error]  found   : (Int, Int) => Int
//  [error]  required: Int => ?
//  [error]   Option(1) map sum2Ints
//  [error]                 ^
```

--

```scala
Option(1) map sum2Ints.curried
// res2: Option[Int => Int] = Some(scala.Function2$$Lambda$4648/454529628@7c9e8cef)
```

--

*map* doesn't help us to fuse another Option(2) to that.

---

## ... Applicative can help us out

--

```scala
Option(1) map sum2Ints.curried ap Option(2)
// res3: Option[Int] = Some(3)
```

--

```scala
sum2Ints.curried.pure[Option] ap Option(1) ap Option(2)
// res4: Option[Int] = Some(3)
```

--

```scala
sum2Ints.curried.pure[Option] ap 1.pure[Option] ap 2.pure[Option]
// res5: Option[Int] = Some(3)               // pure is the same as Option.apply
```

--

```scala
Applicative[Option].ap2(sum2Ints.pure[Option])(Option(1), Option(2))
// res6: Option[Int] = Some(3)              // no currying with ap2
```

--

```scala
Applicative[Option].map2(Option(1), Option(2))(sum2Ints)
// res7: Option[Int] = Some(3)              // no pure with map2
```

--

```scala
(Option(1), Option(2)) mapN sum2Ints
// res8: Option[Int] = Some(3)              // Tuple2#mapN
```

---

## Cartesian Product

When working with Applicative we always get the Cartesian product of two or more contexts.
That isn't immediately obvious when working with the *Option* context
but becomes evident when we work with *List*.

--

```scala
val add2: Int => Int => Int = ((_:Int) + (_:Int)).curried
val mult2: Int => Int => Int = ((_:Int) * (_:Int)).curried
val concat: (String, String) => String = _ ++ _
```

--

```scala
List((_:Int) * 0, (_:Int) + 100, (x:Int) => x * x) ap List(1, 2, 3)
// res10: List[Int] = List(0, 0, 0, 101, 102, 103, 1, 4, 9)
```

--

```scala
List(add2, mult2) <*> List[Int](1, 2) <*> List[Int](100, 200)
// res11: List[Int] = List(101, 201, 102, 202, 100, 200, 200, 400)
```

--

```scala
concat.curried.pure[List] <*> List("ha", "heh", "hmm") <*> List("?", "!", ".")
// res12: List[String] = List(ha?, ha!, ha., heh?, heh!, heh., hmm?, hmm!, hmm.)
```

--

```scala
List("ha", "heh", "hmm") map concat.curried ap List("?", "!", ".")
// res13: List[String] = List(ha?, ha!, ha., heh?, heh!, heh., hmm?, hmm!, hmm.)
```

---

class: middle, center

# 5. Applicative Processing
<br/>
<br/>
<br/>
<br/>
<br/>

.footnote[
&nbsp; &nbsp; &nbsp; &nbsp; See: *examples.ApplicativeProcessing*
]

---

## Trait Applicative
<br/>

--

Applicative is stronger than Functor, but weaker than Monad.
<br/>
<br/>

--

```scala
trait Functor[F[_]] { // simplified

  def map[A, B](fa: F[A])(f: A => B): F[B]
}
```

--

```scala
trait Applicative[F[_]] extends Functor[F] { // simplified

  def pure[A](a: A): F[A]

  def ap[A, B](ff: F[A => B])(fa: F[A]): F[B]
}
```

--

```scala
trait Monad[F[_]] extends Applicative[F] { // simplified

  def flatMap[A, B](fa: F[A])(f: A => F[B]): F[B]
}
```

---

## Replacing monadic with applicative context
<br/>

--

Applicative is strong enough for the problem<br/>
we solved before with a monad-comprehension.

--

<br/>
Monadic context: *F[_]* constrained to be a *Monad*

```scala
def processABC[F[_]: Monad, A, B, C, D](compute: (A, B, C) => D)
                                       (fa: F[A], fb: F[B], fc: F[C]): F[D] =
  ??? // monadic solution
```
<br/>

--

Applicative context: *F[_]* constrained to be an *Applicative*

```scala
def processABC[F[_]: Applicative, A, B, C, D](compute: (A, B, C) => D)
                                           (fa: F[A], fb: F[B], fc: F[C]): F[D] =
  ??? // applicative solution
```
<br/>

--

Let's start with *Option[Int]* again and then abstract the solution.

---

## Solution with *Applicative#ap*:

### Example context/effect: *Option*
<br/>

```scala
def processInts(compute: (Int, Int, Int) => Int)
               (oi1: Option[Int], oi2: Option[Int], oi3: Option[Int])
               : Option[Int] = {
  val f3Curried: Int => Int => Int => Int = compute.curried
  val of3: Option[Int => Int => Int => Int] = Some(f3Curried) // lifting
  val of2: Option[Int => Int => Int] = of3 ap oi1 // same as: oi1 map of3
  val of1: Option[Int => Int] = of2 ap oi2
  val result: Option[Int] = of1 ap oi3
  result
}
```

*Some(f3Curried)* lifts the curried function into the *Option* context.

---

## Abstracting &nbsp; *Option* &nbsp; to &nbsp; *F[_]: Applicative*
<br/>
<br/>
<br/>

```scala
def processInts[F[_]: Applicative](compute: (Int, Int, Int) => Int)
                                  (fi1: F[Int], fi2: F[Int], fi3: F[Int])
                                  : F[Int] = {
  val fCurried: Int => Int => Int => Int = compute.curried
  val ff: F[Int => Int => Int => Int] = Applicative[F].pure(fCurried) // lifting
  ff ap fi1 ap fi2 ap fi3
}
```

*Applicative[F].pure(fCurried)* lifts the curried function into the generic *F* context.

---

## Abstracting away the *Int*s
<br/>
<br/>
<br/>

```scala
def processABC[F[_]: Applicative, A, B, C, D](compute: (A, B, C) => D)
                                             (fa: F[A], fb: F[B], fc: F[C])
                                             : F[D] = {
  val fCurried: A => B => C => D = compute.curried
  val ff: F[A => B => C => D] = Applicative[F].pure(fCurried)
  ff ap fa ap fb ap fc
}
```

---

## Using *pure* syntax and _&lt;*&gt;_ (alias for *ap*)
<br/>
<br/>
<br/>

```scala
def processABC[F[_]: Applicative, A, B, C, D](compute: (A, B, C) => D)
                                             (fa: F[A], fb: F[B], fc: F[C])
                                             : F[D] = {
  compute.curried.pure[F] <*> fa <*> fb <*> fc
}
```

---

## *Applicative#ap3* saves us from currying
<br/>
<br/>
<br/>

```scala
def processABC[F[_]: Applicative, A, B, C, D](compute: (A, B, C) => D)
                                             (fa: F[A], fb: F[B], fc: F[C])
                                             : F[D] = {
  Applicative[F].ap3(compute.pure[F])(fa, fb, fc)
}
```

---

## *Applicative#map3* avoids lifting with *pure*
<br/>
<br/>
<br/>

```scala
def processABC[F[_]: Applicative, A, B, C, D](compute: (A, B, C) => D)
                                             (fa: F[A], fb: F[B], fc: F[C])
                                             : F[D] = {
  Applicative[F].map3(fa, fb, fc)(compute)
}
```

*map2*, *map3* .. *map22* are available for *Applicative*.

---

## *Apply* is just *Applicative* without *pure*
<br/>
<br/>
<br/>

```scala
def processABC[F[_]: Apply, A, B, C, D](compute: (A, B, C) => D)
                                       (fa: F[A], fb: F[B], fc: F[C])
                                       : F[D] = {
  Apply[F].map3(fa, fb, fc)(compute)
}
```

*map2*, *map3* .. *map22* come from *Apply*.

*Apply* is a base trait of *Applicative* and provides us *map3*.

---

## Using *Tuple3#mapN* for convenience
<br/>
<br/>
<br/>

```scala
def processABC[F[_]: Apply, A, B, C, D](compute: (A, B, C) => D)
                                       (fa: F[A], fb: F[B], fc: F[C])
                                       : F[D] = {
  (fa, fb, fc) mapN compute
}
```

We just tuple up the three *F*'s and invoke *mapN* with a function
that takes three parameters. *mapN* fuses the *F*'s into an *F*-result.

Cats provides *mapN* as an enrichment for *Tuple2*, *Tuple3* .. *Tuple22*.

---

## Comparing the solutions
<br/>

--

### Monadic solution:

```scala
def processABC[F[_]: Monad, A, B, C, D](compute: (A, B, C) => D)
                                       (fa: F[A], fb: F[B], fc: F[C]): F[D] =
  for {
    a <- fa
    b <- fb
    c <- fc
  } yield compute(a, b, c)
```

--

### Applicative solution:

```scala
def processABC[F[_]: Apply, A, B, C, D](compute: (A, B, C) => D)
                                       (fa: F[A], fb: F[B], fc: F[C]) : F[D] =
  (fa, fb, fc) mapN compute
```

---

## Currying again
<br/>

--

We provided *processABC* with two parameter lists.

```scala
def processABC[F[_]: Apply, A, B, C, D](compute: (A, B, C) => D)
                                       (fa: F[A], fb: F[B], fc: F[C]) : F[D] =
  (fa, fb, fc) mapN compute
```

--

This improves <u>composability</u> and allows us provide the *compute* function and the effectful *F*'s in independent steps.

--

```scala
// providing the computation
def processEffectfulInts[F[_]: Apply](fi1: F[Int], fi2: F[Int], fi3: F[Int])
                                     : F[Int] =
  processABC(sum3Ints)(fi1, fi2, fi3)
```

--

```scala
// providing the 'effectful' parameters
val result1 = processEffectfulInts(Option(1), Option(2), Option(3))
// result1: Option[Int] = Some(6)
val result2 = processEffectfulInts(List(1, 2), List(10, 20), List(100, 200))
// result2: List[Int] = List(111, 211, 121, 221, 112, 212, 122, 222)
```

---

class: middle, center

# 6. Comparing Monad with Applicative
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## Sequential vs. parallel
<br/>

--

### Monads enforce sequential operation!

Imagine a for-comprehension.<br/>
The generators are executed in sequence, one after the other.<br/>
The yield clause is executed after all generators have finished.<br/>

--

### Applicatives allow for parallel/independent operations!

The operations are by nature <u>independent</u> of each other.<br/>
(That does not mean, they are asynchronous.)<br/>

---

## Fail-fast semantics
<br/>

--

### Monads enforce short-circuiting!

If an 'erraneous' value (e.g. *None*, *Nil* or *Left*) is found in a monadic computation,
the computation stops immediately, because the result will not change if processing were continued.<br/>
That is why we are not able to collect errors.

--

### Applicatives do not short-circuit!

As applicative operations are independent of each other, processing does not stop if an error occurs.<br/>
It is possible to collect errors (see: *cats.data.Validated*)<br/>
*cats.data.Validated* has an Applicative instance, but no Monad instance.

We will come to that later.

---

## Composition
<br/>

--

### Monads do not compose!

In order to kind of 'compose' Monads we need an extra construct such as a Monad Transformer
which itself is a Monad. I.e.: If we want to compose two Monads we need a third Monad to stack them up.
(Another way to compose Monads is Kleisli composition.)

--

### Applicatives compose!

Composition of (Functor and) Applicative is a breeze.<br/>
It is genuinely supported by these type classes.

.footnote[
See: *examples.Composition*
]

---

## Composition - Code

```scala
val loi1 = List(Some(1), Some(2))
val loi2 = List(Some(10), Some(20))
```

### Monads do not compose!

```scala
def processMonadic(xs: List[Option[Int]], ys: List[Option[Int]]): List[Option[Int]] = {
  val otli: OptionT[List, Int] = for {
      x <- OptionT[List, Int](xs)
      y <- OptionT[List, Int](ys)
    } yield x + y
  otli.value
}
val result1 = processMonadic(loi1, loi2)
// result1: List[Option[Int]] = List(Some(11), Some(21), Some(12), Some(22))
```

### Applicatives compose!

```scala
def processApplicative(xs: List[Option[Int]], ys: List[Option[Int]]): List[Option[Int]] =
  Applicative[List].compose[Option].map2(xs, ys)((_:Int) + (_:Int))

val result2 = processApplicative(loi1, loi2)
// result2: List[Option[Int]] = List(Some(11), Some(21), Some(12), Some(22))
```

---

## When to use which
<br/>

### Use Applicative if all computations are <u>independent</u> of each other.

Howto:

- Write a monadic solution with a for-comprehension.
- If the generated values (to the left of the generator arrow *&lt;-* )
are only used in the *yield* clause at the end (not in an other generator)
the computations are independent and allow for an applicative solution.
- Tuple up the computations and *mapN* them with a function
which fuses the computation results to a final result.

(This howto is applicable only if the effect in question also has a Monad instance.)

---

## When to use which - counter example
<br/>

```scala
val result =
  for {
    x <- Future { computeX }
    y <- Future { computeY(x) }
    z <- Future { computeZ(x, y) }
  } yield resultFrom(z)
```

In this for-comprehension the subsequent computations depend on the previous ones.

Hence this for-comprehension cannot be substituted by applicative processing.

---

## Principle of Least Power
<br/>

**Given a choice of solutions,**<br/>
**pick the least powerful solution**<br/>
**capable of solving your problem.**

\-- Li Haoyi

---

class: middle, center

# 7. The Applicative trait
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## Typeclass Functor

*Functor* is the base trait of *Applicative*.
<br/>
<br/>

```scala
trait Functor[F[_]] {

  // ----- primitive map

  def map[A, B](fa: F[A])(f: A => B): F[B]

  // ----- implementations in terms of the primitive map

  def fmap[A, B](fa: F[A])(f: A => B): F[B] = map(fa)(f) // alias for map

  def lift[A, B](f: A => B): F[A] => F[B] = fa => map(fa)(f)

  def as[A, B](fa: F[A], b: B): F[B] = map(fa)(_ => b)

  def void[A](fa: F[A]): F[Unit] = as(fa, ())

  def compose[G[_]: Functor]: Functor[Lambda[X => F[G[X]]]] = ???
}
```

---

## Typeclass Applicative
with primitives *pure* and *ap*
<br/>
<br/>

```scala
trait Applicative[F[_]] extends Functor[F] {

  // ----- primitives

  def pure[A](a: A): F[A]
  def ap[A, B](ff: F[A => B])(fa: F[A]): F[B]

  // ----- implementations in terms of the primitives

  def map2[A, B, Z](fa: F[A], fb: F[B])(f: (A, B) ⇒ Z): F[Z] =
    ap(map(fa)(a => f(a, _: B)))(fb)

  override def map[A, B](fa: F[A])(f: A => B): F[B] =
    ap(pure(f))(fa)

  def product[A, B](fa: F[A], fb: F[B]): F[(A, B)] =
    map2(fa, fb)((_, _))
}
```

---

## Typeclass Applicative
with primitives *pure* and *map2*
<br/>
<br/>

```scala
trait Applicative[F[_]] extends Functor[F] {

  // ----- primitives

  def pure[A](a: A): F[A]
  def map2[A, B, Z](fa: F[A], fb: F[B])(f: (A, B) ⇒ Z): F[Z]

  // ----- implementations in terms of the primitives

  def ap[A, B](ff: F[A => B])(fa: F[A]): F[B] =
    map2(ff, fa)((f, a) => f(a)) // or: map2(ff, fa)(_(_))

  override def map[A, B](fa: F[A])(f: A => B): F[B] =
    map2(fa, pure(()))((a, _) => f(a))

  def product[A, B](fa: F[A], fb: F[B]): F[(A, B)] =
    map2(fa, fb)((_, _))
}
```

---

## Typeclass Applicative
with primitives *pure* and *map* and *product*
<br/>
<br/>

```scala
trait Applicative[F[_]] extends Functor[F] {

  // ----- primitives

  def pure[A](a: A): F[A]
  override def map[A, B](fa: F[A])(f: A => B): F[B]
  def product[A, B](fa: F[A], fb: F[B]): F[(A, B)]

  // ----- implementations in terms of the primitives

  def map2[A, B, Z](fa: F[A], fb: F[B])(f: (A, B) => Z): F[Z] =
    map(product(fa, fb)) { case (a, b) => f(a, b) }

  def ap[A, B](ff: F[A => B])(fa: F[A]): F[B] =
    map2(ff, fa)((f, a) => f(a)) // or: map2(ff, fa)(_(_))
}
```

---

## Typeclass Applicative

```scala
trait Applicative[F[_]] extends Functor[F] {

  // ----- primitives
  def pure[A](a: A): F[A]
  def ap[A, B](ff: F[A => B])(fa: F[A]): F[B]

  // ----- implementations in terms of the primitives
  override def map[A, B](fa: F[A])(f: A => B): F[B] = ap(pure(f))(fa)

  def <*>[A, B](ff: F[A => B])(fa: F[A]): F[B] = ap(ff)(fa) // alias for ap

  def ap2[A, B, Z](ff: F[(A, B) => Z])(fa: F[A], fb: F[B]): F[Z] = {
    val ffBZ: F[B => Z] = ap(map(ff)(f => (a:A) => (b:B) => f(a, b)))(fa)
    ap(ffBZ)(fb)
  } // also: ap3, ap4 .. ap22

  def map2[A, B, Z](fa: F[A], fb: F[B])(f: (A, B) ⇒ Z): F[Z] =
    ap(map(fa)(a => f(a, _: B)))(fb)
  // also: map3, map4 .. map22

  def product[A, B](fa: F[A], fb: F[B]): F[(A, B)] = map2(fa, fb)((_, _))

  def tuple2[A, B](fa: F[A], fb: F[B]): F[(A, B)] = product(fa, fb)
  // also: tuple3, tuple4 .. tuple22

  def compose[G[_]: Applicative]: Applicative[Lambda[X => F[G[X]]]] = ???
}
```

---

class: center

## Cats typeclass hierarchy (a small section of it)

![typeclass hierarchy](cats-typeclass-hierarchy.png "Cats typeclass hierarchy")

.footnote[ .tiny-font[
Complete hierarchy [here](https://camo.githubusercontent.com/e29cc3587dd331d1af177c8ed163de3b15ea04f2/68747470733a2f2f63646e2e7261776769742e636f6d2f74706f6c656361742f636174732d696e666f677261706869632f6d61737465722f636174732e7376673f783d31)
] ]

---

class: middle, center

# 7. Either vs. Validated
<br/>
<br/>
<br/>
<br/>
<br/>

.footnote[
&nbsp; &nbsp; &nbsp; &nbsp; See: *examples.EitherVsValidated*
]

---

## Monadic processing with *Either*
<br/>

Monadic processing enforces fail-fast semantics.<br/>
After an erraneous operation subsequent operations are not executed.<br/>
Hence we get only the first of possibly multiple errors.
<br/>
<br/>

--

```scala
val result: Either[List[String], Int] =
  for {
    x <- 5.asRight[List[String]]
    y <- List("Error 1").asLeft[Int]
    z <- List("Error 2").asLeft[Int] // List("Error 2") is lost!
  } yield x + y + z

// result: Either[List[String],Int] = Left(List(Error 1))
```

---

## Applicative processing with *Either*
<br/>

Applicative processing disables fail-fast semantics.<br/>
But with *Either* we get the same result as before.<br/>
Because *Either* has a Monad instance.
<br/>
<br/>

--

```scala
val result: Either[List[String], Int] =
  ( 5.asRight[List[String]],
    List("Error 1").asLeft[Int],
    List("Error 2").asLeft[Int] // List("Error 2") is lost!
  ) mapN ((_: Int) + (_: Int) + (_: Int))

// result: Either[List[String],Int] = Left(List(Error 1))
```

---

## Applicative processing with *Validated*
<br/>

*cats.data.Validated* is designed in analogy to *Either*.<br/>
Instead of *Right* and *Left* it has *Valid* and *Invalid*.<br/>
*Validated* has an Applicative instance but no Monad instance.
<br/>
<br/>

--

```scala
val result: Validated[List[String], Int] =
  ( 5.valid[List[String]],
    List("Error 1").invalid[Int],
    List("Error 2").invalid[Int] // List("Error 2") is preserved!
  ) mapN ((_: Int) + (_: Int) + (_: Int))

// result: cats.data.Validated[List[String],Int] = Invalid(List(Error 1, Error 2))
```

---

## Conversions between *Either* and *Validated*
<br/>

Conversion is supported in both directions<br/>
*Either#toValidated* converts an *Either* to a *Validated*.<br/>
*Validated#toEither* converts a *Validated* to an *Either*.
<br/>
<br/>

--

```scala
val result: Validated[List[String], Int] =
  ( 5.asRight[List[String]].toValidated,
    List("Error 1").asLeft[Int].toValidated,
    List("Error 2").asLeft[Int].toValidated // List("Error 2") is preserved!
  ) mapN ((_: Int) + (_: Int) + (_: Int))

// result: cats.data.Validated[List[String],Int] = Invalid(List(Error 1, Error 2))

val resultAsEither = result.toEither
// resultAsEither: Either[List[String],Int] = Left(List(Error 1, Error 2))
```

--

<br/>
<br/>
An elaborated example of form validation with *Validated* (contrasted to a solution with *Either*)
can be found in the Cats documentation:<br/>
https://typelevel.org/cats/datatypes/validated.html

---

class: middle, center

# 9. Traversals need Applicative
<br/>
<br/>
<br/>
<br/>
<br/>

.footnote[
&nbsp; &nbsp; &nbsp; &nbsp; See: *examples.Traversals*
]

---

## Recap: *Future.traverse* and *Future.sequence*

Most Scala devs know these methods defined in the *Future* companion object.

--

Let's start with *Future.sequence*.

<u>Future.sequence API doc:</u> *Simple version of Future.traverse. Asynchronously and non-blockingly
transforms a IterableOnce[Future[A]] into a Future[IterableOnce[A]].
Useful for reducing many Futures into a single Future.*

--

Simply spoken: *sequence* turns a *List[Future[A]]* into a *Future[List[A]]*.

```scala
val lfd: List[Future[Double]] = List(Future(2.0), Future(4.0), Future(6.0))
val fld: Future[List[Double]] = Future.sequence(lfd)
```

--

Typically in an application we don't have a *List[Future[B]]*,
but we produce it by processing a *List[A]* asynchronously.<br/>
We can first map the *List[A]* with the function *A => Future[B]*
and then invoke *sequence* on the resulting *List[Future[B]]*
in order to get a *Future[List[B]]*.

--

```scala
val li: List[Int] = List(1, 2, 3)
val doubleItAsync: Int => Future[Double] = x => Future { x * 2.0 }
val lfi: List[Future[Double]] = li.map(doubleItAsync)
val fld: Future[List[Double]] = Future.sequence(lfi)
```

---

## Recap: *Future.traverse* and *Future.sequence*

Mapping and sequencing traverses the list twice.<br/>
*traverse* fuses mapping and sequencing into a single traversal.

--

*Future.traverse* takes a *List[A]* and a mapping function from *A => Future[B]*
and returns a *Future[List[B]]*.

```scala
val li: List[Int] = List(1, 2, 3)
val doubleItAsync: Int => Future[Double] = x => Future { x * 2.0 }
val fld: Future[List[Double]] = Future.traverse(li)(doubleItAsync)
```

--

Providing *identity* as mapping function to *traverse* has the same effect as *sequence*.

```scala
val lfd: List[Future[Double]] = List(Future(2.0), Future(4.0), Future(6.0))
val fld: Future[List[Double]] = Future.traverse(lfd)(identity)
```

---

## Typeclass *Traverse*

Cats generalizes this concept into the *Traverse* typeclass.

--

```scala
trait Traverse[F[_]] extends Foldable[F] with Functor[F] { // simplified

  def traverse[G[_]: Applicative, A, B](fa: F[A])(f: A => G[B]) : G[F[B]]

  def sequence[G[_]: Applicative, A](fga: F[G[A]]): G[F[A]] =
    traverse(fga)(identity)

  // map in terms of traverse using the Id context
  override def map[A, B](fa: F[A])(f: A => B): F[B] = traverse(fa)(f: A => Id[B])
}
```

--

*traverse* and *sequence* require the *G[_]* to be an Applicative (*Future* before).

--

The structure traversed over (*List* before) must be *Foldable with Functor*.
Hence *Traverse* extends these two traits.

--

The *traverse* function can indeed be implemented with *map* and *foldLeft* or *foldRight*.
On the other hand *foldLeft*, *foldRight* and *map* can be implemented with *traverse*.

---

## *Traverse[List].sequence\[Future, A]*
<br/>

Instead of *Future.sequence* we can use *Traverse[List].sequence*.
<br/>
<br/>

--

```scala
val lfd: List[Future[Double]] = List(Future(2.0), Future(4.0), Future(6.0))

val fld1: Future[List[Double]] = Traverse[List].sequence(lfd)
// fld1: scala.concurrent.Future[List[Double]] = Future(Success(List(2.0, 4.0, 6.0)))

import cats.syntax.traverse._ // supports 'sequence' as an enrichment of List

val fld2: Future[List[Double]] = lfd.sequence
// fld2: scala.concurrent.Future[List[Double]] = Future(Success(List(2.0, 4.0, 6.0)))
```

---

## *Traverse[List].traverse\[Future, A, B]*
<br/>

Instead of *Future.traverse* we can use *Traverse[List].traverse*.
<br/>
<br/>

--

```scala
val li: List[Int] = List(1, 2, 3)

val doubleItAsync: Int => Future[Double] = x => Future { x * 2.0 }

val fld1: Future[List[Double]] = Traverse[List].traverse(li)(doubleItAsync)
// fld1: scala.concurrent.Future[List[Double]] = Future(Success(List(2.0, 4.0, 6.0)))

import cats.syntax.traverse._ // supports 'traverse' as an enrichment of List

val fld2: Future[List[Double]] = li traverse doubleItAsync
// fld2: scala.concurrent.Future[List[Double]] = Future(Success(List(2.0, 4.0, 6.0)))
```

---

## *Traverse[Vector].traverse\[Option, A, B]*
<br/>

With *cats.Traverse* can traverse not only over *List*s but over any other *Foldable with Functor*
that has a *Traverse* instance, e.g. *Vector*.
The mapping function may produce any applicative effect, e.g. *Option* instead of *Future*.
<br/>
<br/>

--

```scala
val vi1: Vector[Int] = Vector(3, 2, 1)
val vi2: Vector[Int] = Vector(3, 2, 0)

val divideBy: Int => Option[Double] = x => if (x == 0) None else Some { 6.0 / x }

val ovd1_1 = Traverse[Vector].traverse(vi1)(divideBy)
// ovd1_1: Option[Vector[Double]] = Some(Vector(2.0, 3.0, 6.0))
val ovd1_2 = Traverse[Vector].traverse(vi2)(divideBy)
// ovd1_2: Option[Vector[Double]] = None

import cats.syntax.traverse._ // supports 'traverse' as an enrichment of Vector

val ovd2_1 = vi1 traverse divideBy
// ovd2_1: Option[Vector[Double]] = Some(Vector(2.0, 3.0, 6.0))
val ovd2_2 = vi2 traverse divideBy
// ovd2_2: Option[Vector[Double]] = None
```

---

class: middle, center

# 10. Resources
<br/>
<br/>
<br/>
<br/>
<br/>
&nbsp;

---

## Scala Resources (1/2)

<br/>

- Code and Slides of this Talk:<br/>
  https://github.com/hermannhueck/use-applicative-where-applicable

- Cats documentation:<br/>
  https://typelevel.org/cats/typeclasses/applicative.html<br/>
  https://typelevel.org/cats/typeclasses/traverse.html<br/>
  https://typelevel.org/cats/datatypes/validated.html

- Herding Cats, Day 2 and 3:<br/>
  http://eed3si9n.com/herding-cats/Functor.html<br/>
  http://eed3si9n.com/herding-cats/Semigroupal.html<br/>
  http://eed3si9n.com/herding-cats/Apply.html<br/>
  http://eed3si9n.com/herding-cats/Applicative.html

- "Scala with Cats", Chapters 6 and 7<br/>
  Book by Noel Welsh and Dave Gurnell<br/>
  https://underscore.io/books/scala-with-cats/
  
---

## Scala Resources (2/2)

<br/>

- Live Coding Tutorial on Functor and Applicative by Michael Pilquist<br/>
  FSiS Part 1 - Type Constructors, Functors, and Kind Projector<br/>
  https://www.youtube.com/watch?v=Dsd4pc99FSY<br/>
  FSiS Part 2 - Applicative type class<br/>
  https://www.youtube.com/watch?v=tD_EyIKqqCk

---

## Haskell Resources

<br/>

- Learn You a Haskell for Great Good!, Chapter 11<br/>
  Online book by Miran Lipovaca<br/>
  http://learnyouahaskell.com/functors-applicative-functors-and-monoids

- Applicative Programming with Effects<br/>
  Conor McBride and Ross Paterson in Journal of Functional Programming 18:1 (2008), pages 1-13<br/>
  http://www.staff.city.ac.uk/~ross/papers/Applicative.pdf

- The Essence of the Iterator Pattern<br/>
  Jeremy Gibbons and Bruno C. d. S. Oliveira, Oxford University Computing Laboratory<br/>
  https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf


---

class: middle, center

## Thanks for Listening
<br/>
<br/>
<br/>

# Q &amp; A
<br/>
<br/>
<br/>
<br/>
<br/>

https://github.com/hermannhueck/use-applicative-where-applicable


</textarea>

  <script src="remark-latest.min.js" type="text/javascript">
  </script>
  <script type="text/javascript">
    var slideshow = remark.create({
      // sourceUrl: 'some-source.md',

      // Set the slideshow display ratio
      // Default: '4:3'
      // Alternatives: '16:9', ...
      ratio: '4:3',

      // Navigation options
      navigation: {
        // Enable or disable navigating using scroll
        // Default: true
        // Alternatives: false
        scroll: false,

        // Enable or disable navigation using touch
        // Default: true
        // Alternatives: false
        touch: true,

        // Enable or disable navigation using click
        // Default: false
        // Alternatives: true
        click: false
      }
    });
  </script>
</body>

</html>